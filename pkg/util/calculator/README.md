# Kruise Resource Calculator

A high-performance, thread-safe mathematical expression evaluator designed for Kubernetes resource calculations in SidecarSet dynamic resource allocation scenarios.

## 🎯 Purpose

This calculator is specifically designed to solve the dynamic resource calculation requirements described in [docs/proposals/20250913-sidecarset-dynamic-resources-when-creating.md](../../../docs/proposals/20250913-sidecarset-dynamic-resources-when-creating.md). It enables SidecarSet containers to dynamically compute their resource requirements based on the specifications of target containers within the same Pod during creation time.

## 🚀 Features

### Core Capabilities
- **Thread-safe**: No global state, each calculator instance is independent
- **Resource isolation**: Expression + variables uniquely map to calculator instances  
- **High performance**: Lock-free design for concurrent operations
- **Kubernetes native**: Full support for Kubernetes resource quantities (cpu, memory)
- **Expression validation**: Comprehensive error handling and validation

### Supported Operations
- Basic arithmetic: `+`, `-`, `*`, `/`
- Parentheses: `(` and `)`
- Functions: `max()`, `min()`
- Percentages: e.g., `50%` (represents 0.5)
- Kubernetes resources: e.g., `40m` (40 milli), `100Mi` (100 Mebibytes)

### Value Types
- **Integers**: e.g., `42`
- **Floats**: e.g., `3.14`
- **Percentages**: e.g., `50%` (automatically converts to 0.5)
- **Kubernetes resources**: e.g., `200m`, `512Mi`, `1Gi`

## 🏗️ Architecture

### Design Philosophy

The calculator follows a **resource isolation** pattern where each expression and its variables create a unique calculator instance. This design ensures:

1. **No Lock Contention**: Each instance operates independently
2. **Memory Isolation**: No shared state between different calculations  
3. **Predictable Performance**: O(1) parsing time, no synchronization overhead
4. **Concurrent Safety**: Multiple goroutines can parse different expressions simultaneously

### Core Components

```
┌─────────────────┐
│   Calculator    │
├─────────────────┤
│ expr: string    │  ← Expression string (e.g., "max(cpu*50%, 50m)")
│ variables: map  │  ← Variable bindings (container resources)
│ result: *Value  │  ← Calculation result
└─────────────────┘
         │
         ▼
┌─────────────────┐
│  Parser Engine  │
├─────────────────┤
│ LALR(1) Parser  │  ← Generated by goyacc
│ No Global State │  ← Thread-safe design
│ Error Recovery  │  ← Comprehensive error messages
└─────────────────┘
```

### Parser Architecture

The calculator uses a **LALR(1) parser** generated by `goyacc` with the following components:

1. **Lexer** (`lexer.go`): Tokenizes input strings into meaningful tokens
2. **Grammar** (`calculator.y`): Defines the expression grammar
3. **Parser** (`calculator_y.go`): Generated LALR(1) parser (auto-generated)
4. **Value System**: Handles both numeric and Kubernetes quantity types

## 📋 API Reference

### Basic Usage

```go
import "github.com/openkruise/kruise/pkg/util/calculator"

// Parse simple expression
calc, err := calculator.Parse("2 + 3 * 4")
if err != nil {
    log.Fatal(err)
}
result := calc.GetResult()
fmt.Printf("Result: %s\n", result.String()) // Output: 14
```

### Variable Support

```go
// Define variables (typically container resources)
variables := map[string]*calculator.Value{
    "cpu":    {IsQuantity: true, Quantity: resource.MustParse("200m")},
    "memory": {IsQuantity: true, Quantity: resource.MustParse("512Mi")},
}

// Parse with variables
calc, err := calculator.ParseWithVariables("max(cpu*50%, 50m)", variables)
if err != nil {
    log.Fatal(err)
}
result := calc.GetResult()
fmt.Printf("Result: %s\n", result.String()) // Output: 100m
```

### Calculator Instance Methods

```go
type Calculator struct {
    expr      string                    // Original expression
    variables map[string]*Value        // Variable bindings
    result    *Value                    // Calculation result
}

// GetResult returns the calculation result
func (c *Calculator) GetResult() *Value

// GetExpression returns the original expression
func (c *Calculator) GetExpression() string

// GetVariables returns the variable bindings
func (c *Calculator) GetVariables() map[string]*Value
```

## 📊 Operation Rules

### Basic Arithmetic Operations

| Operation | Rule | Example |
|-----------|------|---------|
| Addition | If either operand is Quantity, both convert to Quantity | `100m + 50m` → `150m` |
| Subtraction | If either operand is Quantity, both convert to Quantity | `100m - 50m` → `50m` |
| Multiplication | Quantity × Number only | `40m * 2` → `80m` |
| Division | Quantity ÷ Number only | `100m / 2` → `50m` |

### Error Conditions

| Condition | Error Message |
|-----------|---------------|
| Division by zero | `division by zero` |
| Multiplication of two Quantities | `multiplication of two quantities` |
| Division by Quantity | `division by quantity` |
| Negative result | `calculation result is negative` |
| Unknown function | `unknown function: <name>` |
| Undefined variable | `undefined variable: <name>` |

## 🔧 Developer Guide

### Yacc File Management

The calculator uses `goyacc` for parser generation. Key files:

- **`calculator.y`**: Grammar definition file (source of truth)
- **`calculator_y.go`**: Generated parser code (auto-generated, do not edit)
- **`y.output`**: Debug information (optional, can be ignored)

#### Modifying the Grammar

1. **Edit `calculator.y`**: Make changes to the grammar definition
2. **Regenerate parser**: Run the generation command
3. **Test thoroughly**: Ensure all existing functionality still works

#### Parser Generation Workflow

```bash
# Generate parser from grammar
goyacc -o calculator_y.go -p yy calculator.y

# Run tests to verify changes
go test -v

# Run concurrent safety tests
go test -v -run TestConcurrent
```

#### Grammar Development Best Practices

1. **Keep grammar simple**: LALR(1) parsers work best with simple grammars
2. **Test edge cases**: Especially error conditions and type conversions
3. **Maintain backward compatibility**: Existing expressions should continue to work
4. **Add comprehensive tests**: Each new feature needs unit tests

### Testing

#### Unit Tests
```bash
go test -v
```

#### Concurrent Safety Tests
```bash
go test -v -run TestConcurrent
```

#### Coverage Report
```bash
go test -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html
```

### Performance Characteristics

- **Time Complexity**: O(n) where n is the length of the expression
- **Space Complexity**: O(1) for parsing, O(m) for m variables
- **Concurrency**: Lock-free, supports unlimited concurrent operations
- **Memory**: Each calculator instance is self-contained

## 💡 Examples

### Basic Operations
```go
// Simple arithmetic
calc, _ := calculator.Parse("2 + 3 * 4")
fmt.Println(calc.GetResult().String()) // 14

// Percentage operations
calc, _ = calculator.Parse("50% * 200")
fmt.Println(calc.GetResult().String()) // 100

// Function calls
calc, _ = calculator.Parse("max(10, 20)")
fmt.Println(calc.GetResult().String()) // 20
```

### Kubernetes Resources
```go
// Resource arithmetic
calc, _ := calculator.Parse("100m + 50m")
fmt.Println(calc.GetResult().String()) // 150m

// Resource with percentage
calc, _ = calculator.Parse("40m * 2")
fmt.Println(calc.GetResult().String()) // 80m

// Mixed operations
calc, _ = calculator.Parse("max(40m, 20)")
fmt.Println(calc.GetResult().String()) // 20
```

### SidecarSet Use Case
```go
// Typical SidecarSet resource calculation
variables := map[string]*calculator.Value{
    "cpu": {IsQuantity: true, Quantity: resource.MustParse("200m")},
    "memory": {IsQuantity: true, Quantity: resource.MustParse("512Mi")},
}

// Calculate sidecar resources based on main container
calc, _ := calculator.ParseWithVariables("max(cpu*50%, 50m)", variables)
fmt.Println(calc.GetResult().String()) // 100m

calc, _ = calculator.ParseWithVariables("max(memory*50%, 100Mi)", variables)
fmt.Println(calc.GetResult().String()) // 256Mi
```

## 🚨 Error Handling

The calculator provides detailed error messages for debugging:

```go
calc, err := calculator.Parse("10 / 0")
if err != nil {
    fmt.Printf("Error: %v\n", err) // division by zero
}

calc, err = calculator.Parse("40m * 2m")
if err != nil {
    fmt.Printf("Error: %v\n", err) // multiplication of two quantities
}
```

## 🤝 Contributing

When contributing to the calculator:

1. **Grammar Changes**: Modify `calculator.y` and regenerate parser
2. **Add Tests**: Every feature needs comprehensive unit tests
3. **Update Documentation**: Keep README.md current
4. **Performance**: Ensure changes don't degrade performance
5. **Compatibility**: Maintain backward compatibility

### Development Workflow

```bash
# 1. Make changes to calculator.y
vim calculator.y

# 2. Regenerate parser
goyacc -o calculator_y.go -p yy calculator.y

# 3. Run all tests
go test -v ./...

# 4. Check coverage
go test -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html

# 5. Commit changes (include both .y and generated .go files)
git add calculator.y calculator_y.go
git commit -m "feat: add new expression support"
```

## 📚 References

- [SidecarSet Dynamic Resources Proposal](../../../docs/proposals/20250913-sidecarset-dynamic-resources-when-creating.md)
- [GoYacc Documentation](https://pkg.go.dev/golang.org/x/tools/cmd/goyacc)
- [Kubernetes Resource Model](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)
- [LALR Parser Theory](https://en.wikipedia.org/wiki/LALR_parser)

## 📄 License

This project is part of the OpenKruise project and follows the same license terms.